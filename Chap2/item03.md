# [이펙티브 자바] item03 private 생성자나 열거 타입으로 싱글턴임을 보증하라.

> ### 싱글턴(singleton): 인스턴스를 오직 하나만 생성할 수 있는 클래스

**클래스를 싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다.**

싱글톤의 예: 무상태 객체, 설계상 유일해야 하는 시스템 컴포넌트
- 무상태(stateless): 우리가 보통 아는 클라이언트와 서버 관계에서 서버가 클라이언트 상태를 보존하지 않는다.

무상태를 사용하면 클라이언트의 정보를 서버가 저장하지 않기 때문에 처리가 끝나면 연결을 바로 종료하므로 많이 몰려도 서버에 과부하가 덜 걸린다.

## 싱글턴을 만드는 보통의 방식

두 방식 모두 생성자를 private로 감춰두고 접근할 public static 멤버를 하나 마련해둔다.

- ### 1. public static 멤버가 final 필드인 방식

```java
public class Elvis {
	public static final Elvis INSTANCE = new Elvis();
  private Elvis() {...}
    
  public void leaveTheBuilding() {...}
}

```
private 생성자는 public static final 필드를 초기화할 때 딱 한 번만 호출된다.<br>

**예외**: AccessibleObject.setAccessible을 사용해 private 생성자를 호출하는 것이다.<br>
reflect의 Field 와 Method 객체를 받아서 setAccessible를 설정해주면 호출이 가능하다.<br>
**생성자를 수정하여 두 번째 객체가 생성되려 할 때 예외를 던지게 하여 막아줄 수 있다.**

**장점** 
- 해당 클래스가 싱글텀임이 API에 명백히 드러난다.
- 간결함.
    
<br>

    
- ### 2. 정적 팩터리 메서드를 public static 멤버로 제공하는 방식

>
```java
public class Elvis {
	  private static final Elvis INSTANCE = new Elvis();
    private Elvis() {...}
    public static Elvis getInstance() { return INSTANCE; }
    
    public void leaveTheBuilding() {...}
}

```

Elvis.getInstance는 항상 같은 객체의 참조를 반환하므로 제2의 Elvis 인스턴스란 결코 만들어지지 않는다.

**장점**
- API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다.
  - 유일한 인스턴스를 반환하던 팩터리 메서드가 호출하는 스레드별로 다른 인스턴스를 넘겨주게 할 수 있다.
  - 멀티 스레드 환경에선 getInstance 메서드에 진입할 때 인스턴스가 하나가 아니게 될 수 있다.(Thread-safe)
  - thread-safe: 한 스레드가 함수를 호출했을 때 다른 스레드가 그 함수를 함께 실행하더라도 각 스레드에 수행 결과가 올바르게 나오는 것

- 원한다면 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있다는 점이다.
- 정적 팩터리의 메서드 참조를 공급자(Supplier)로 사용할 수 있다는 점이다.
  - 스트림을 사용해서 Elvis::getInstance로 사용

이러한 장점들이 굳이 필요하지 않다면 public 필드 방식이 좋다.


## 싱글톤 클래스 직렬화
위의 두 방식으로 클래스를 직렬화 하려면 Serializable을 구현하면 되지만 싱글톤 클래스에선 부족하다.<br>
역직렬화할 때 새로운 인스턴스가 만들어져서 문제가 발생한다.<br>
&rarr; 모든 인스턴스 필드에 transient 선언 + readResolve 메서드를 제공


## 열거 타입 방식의 싱글톤
```java
public enum Elvis {
  INSTANCE;
  
  public void leaveTheBuilding() {...}
}

```

간결하고, 추가 노력 없이 직렬화 할 수 있다. 심지어 아주 복잡한 직렬화 상황이나 리플렉션 공격에서도 제2의 인스턴스가 생기는 일을 완벽히 막아준다.<br>
**대부분 상황에서는 원소가 하나뿐인 열거 타입이 싱글톤을 만드는 가장 좋은 방법이다.**<br>
&rarr; 직렬화 가능 인스턴스 통제 클래스를 작성해야 하는데, 컴파일 타임에는 어떤 인스턴스가 있는지 알 수 없는 상황이라면 열거 타입으로 표현 불가능<br>
&rarr; 싱글톤이 Enum 외의 클래스를 상속해야 할 때도 사용 불가능



## 질문
1. readResolve가 뭘까?
- 역질렬화 과정에서 별도의 처리가 필요할 때는 readObject 메서드를 클래스 내부에 선언해 한다. 이때 어던 ReadObject를 사용하더라도 싱글톤 객체에서 초기화될 때 만들어진 인스턴스를 반환하지 않는다.
이 때 readResolve를 사용하면 새로 생성된 객체 대신에 초기화할 때 만들어진 인스턴스를 반환하면서 새로 생성된 객체는 유지하지 않게 되어 가비지 컬렉션에 들어간다.
2. 싱글톤이 테스트하기 어려운 이유?
Soild 원칙을 위반하기 때문에 테스트가 어렵다.
여기선 DIP, OCP 원칙을 위반한다.
- DIP 원칙: 구체화에 의존하는 것이 아니라 추상화에 의존해야 한다.<br>
&rarr; 미리 초기화 하므로 구체화에 의존하게 됨.
- OCP 원칙: 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다
&rarr; 인터페이스를 구현해서 만든 싱글턴이라도 역할이 복잡한 경우 해당 싱글톤 객체를 사용하는 다른 객체간의 결함도가 높아져서 객체 지향 설계의 어긋난다.  
3. 싱글톤이 테스트하기 어려운데도 사용하는 이유와 어떻게 가능한지?
&rarr; 클라이언트, 서버 관계에서 클라이언트가 서버에 접속할 때 마다 객체가 만들어지면 메모리 낭비가 심하므로 싱글톤 방식을 사용함.
스프링에선 싱글톤 컨테이너를 사용하여 DIP, OCP 문제를 해결한다.

