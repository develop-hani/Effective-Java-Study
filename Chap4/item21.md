# 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8 이전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 메서드를 추가할 방법이 없었다.<br>
자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드가 소개됐다.<br>
디폴트 메서드를 선언하면, 그 인터페이스를 구현한 후 디폴트 메서드를 재정의하지 않은 모든 클래스에서 디폴트 구현이 쓰이게 된다.

- 디폴트 메서드를 추가할 수 있다고 해도 위험이 완전히 사라진 것은 아니다.<br>
 디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 '삽입'할 뿐이다.<br>
 **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하기란 어려운 법이다.**

## 디폴트 메서드를 작성하기 어려운 예

```java
// 자바 8의 Collection 인터페이스에 추가된 디폴트 메서드
default boolean removeIf(Predicate<? super E> filter) {
	Objects.requireNonNull(filter);
    boolean result = false;
    for (Iterator<E> it = iterator(); it.hasNext(); ) {
    	if (filter.test(it.next())) {
    		it.remove();
        	result = true;
        }
    }
	return result;
}
```

아파치 버전(SynchronizedCollection)은 클라이언트가 제공한 객체로 락을 거는 능력을 추가로 제공한다.
SynchronizedCollection은 디폴트 메서드를 재정의 하지 않았기 때문에 위의 코드의 디폴트 구현을 물려받게 된다.<br>
&rarr; 따라서 SynchronizedCollection의 인스턴스를 여러 스레드가 공유하는 환경에서 한 스레드가 removeIf 메서드를 호출하면 예기치 못한 결과로 이어질 수 있다.

* 이를 예방하기 위해 구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하였다.<br>
&rarr; 하지만 자바 플랫폼에 속하지 않은 구현체들은 이러한 변화에 맞춰 수정되지 않았을 수도 있다.

- **디폴트 메서드는 기존 구현체에 런타임 오류를 일으킬 수 있다.**



## 정리

- **새로운 인터페이스를 만드는 경우가 아니면, 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니라면 피해야 한다.**
- **새로운 인터페이스를 만들 때에도 테스트를 반드시 거쳐야 한다.**
