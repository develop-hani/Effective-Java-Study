스레드보다는 실행자, 태스크, 스트림을 애용하라
=
## 단순한 작업 큐
- 이 클래스는 클라이언트가 요청한 작업을 백그라운드 스레드에 위임해 비동기적으로 처리해준다.
- 작업 큐가 필요 없어지면 클라이언트는 큐에 중단을 요청할 수 있고, 그러면 큐는 남아 있는 작업을 마저 완료한 후 스스로 종료한다.
- 안전 실패나 응답불가가 될 여지를 없애기 위해서 장황한 코드가 필요하다.
## 실행자 프레임워크
- java.util.concurrent 패키지
- 실행자 프레임워크라고 하는 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있다.
- 단순한 작업 큐를 사용한 코드보다 뛰어난 작업 큐를 단 한줄로 간편하게 생성할 수 있다.
```java
ExecutorService exec = Executors.newSingleThreadExecutor(); // 작업 큐 생성
exec.execute(runnable); // 이 실행자에 실행할 태스크를 넘기는 방법
exec.shutdown(); // 실행자를 종료시키는 방법, 실패시 VM자체가 종료되지 않음
```
### 실행자 서비스의 주요 기능들
- 특정 태스크가 완료되기를 기다린다.
- 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.
- 완료된 태스크들의 결과를 차례로 받는다.
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 한다.
### 실행자 서비스의 사용
- 큐를 둘 이상의 스레드가 처리하게 하고 싶다면 다른 정적 팩터리를 이용하여 다른 종류의 실행자 서비스(스레드 풀)를 생성하면 된다. 
스레드 풀의 스레드 개수는 고정할 수도 있고 필요에 따라 늘어나거나 줄어들게 설정할 수도 있다.
- 주요 실행자 대부분은 java.util.concurrent.Executors의 정적 팩터리를 이용해 생성할 수 있고, 평범하지 않은 실행자를 원한다면 ThreadPoolExecutor 클래스를 직접 사용해도 된다.
- Executors.newCachedThreadPool은 작은 프로그램이나 가벼운 서버에는 일반적으로 좋지만, 무거운 프로덕션 서버에는 적합하지 않다. 
이런 경우 ThreadPoolExecutor 클래스를 직접 사용하는 편이 낫다
## 태스크
작업 큐를 손수 만드는 일을 삼가야 하고, 스레드를 직접 다루는것도 일반적으로 삼가야 한다. 
스레드를 직접 다루면 Thread가 작업 단위와 수행 메커니즘 역할들 모두 수행하게 된다. 
반면 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리된다.\
작업 단위를 나타내는 핵심 추상 개념이 ```태스크```다.
- 태스크에는 Runnable과 Callable 두가지가 있다. (Callable은 Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다.
- 태스크를 수행하는 일반적인 매커니즘이 실행자 서비스이다.
- 태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 언제든 변경할 수 있다. (실행자 프레임워크가 작업 수행을 담당해준다)
### 포크-조인 태스크
- 포크-조인 풀이라는 특별한 실행자 서비스가 실행해준다.
- 포크-조인 태스크의 인스턴스는 작은 하위 태스크로 나뉠수 있고, ForkJoinPool을 구성하는 스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할수도 있다.
- ForkJoinPool을 이용해 만든 병렬 스트림을 이용하면 적은 노력으로 이점을 얻을 수 있다.
